---
title: "X√¢y D·ª±ng Agent ƒê·∫ßu Ti√™n: Instructions, Tools v√† Function Calling"
date: 2025-05-21 09:00:00 +0700
categories: [AI, OpenAI]
tags: [openai, agents, tools, function-calling, python]
author: toantranct
description: H∆∞·ªõng d·∫´n chi ti·∫øt c√°ch vi·∫øt instructions hi·ªáu qu·∫£ v√† t·∫°o function tools cho OpenAI Agents. T·ª´ basic function calling ƒë·∫øn advanced tool patterns.
---

Trong b√†i tr∆∞·ªõc, ch√∫ng ta ƒë√£ l√†m quen v·ªõi nh·ªØng kh√°i ni·ªám c∆° b·∫£n c·ªßa OpenAI Agents SDK. Nh∆∞ng ƒë·ªÉ t·∫°o ra nh·ªØng agents th·ª±c s·ª± h·ªØu √≠ch, ch√∫ng ta c·∫ßn trang b·ªã cho ch√∫ng kh·∫£ nƒÉng **th·ª±c hi·ªán h√†nh ƒë·ªông** th√¥ng qua tools v√† **hi·ªÉu r√µ nhi·ªám v·ª•** th√¥ng qua instructions hi·ªáu qu·∫£.

H√¥m nay, ch√∫ng ta s·∫Ω kh√°m ph√° c√°ch bi·∫øn agents t·ª´ nh·ªØng "chatbot ƒë∆°n thu·∫ßn" th√†nh nh·ªØng "digital workers" c√≥ th·ªÉ t∆∞∆°ng t√°c v·ªõi APIs, x·ª≠ l√Ω d·ªØ li·ªáu, v√† th·ª±c hi·ªán c√°c t√°c v·ª• ph·ª©c t·∫°p trong th·∫ø gi·ªõi th·ª±c.

## Kh√°i ni·ªám c∆° b·∫£n

### Instructions

**Instructions (System prompt)** l√† t·∫≠p h·ª£p c√°c h∆∞·ªõng d·∫´n ƒë·ªãnh nghƒ©a nhi·ªám v·ª•, vai tr√≤, v√† gi·ªõi h·∫°n cho m·ªôt Agent. Instructions gi√∫p Agent hi·ªÉu r√µ m·ª•c ti√™u v√† c√°ch th·ª©c ph·∫£n h·ªìi, t·ª´ ƒë√≥ ƒë·∫£m b·∫£o k·∫øt qu·∫£ nh·∫•t qu√°n v√† ch√≠nh x√°c h∆°n.

### Tools

**Tools** l√† c√°c ch·ª©c nƒÉng ho·∫∑c ph∆∞∆°ng th·ª©c ƒë∆∞·ª£c cung c·∫•p ƒë·ªÉ Agent t∆∞∆°ng t√°c v·ªõi th·∫ø gi·ªõi b√™n ngo√†i nh∆∞ l·∫•y th√¥ng tin, x·ª≠ l√Ω d·ªØ li·ªáu, hay th·ª±c hi·ªán c√°c h√†nh ƒë·ªông c·ª• th·ªÉ. V√≠ d·ª•: l·∫•y th√¥ng tin th·ªùi ti·∫øt, g·ª≠i email, t√≠nh to√°n d·ªØ li·ªáu‚Ä¶

## T·∫°i Sao Instructions v√† Tools Quan Tr·ªçng?

### Instructions - B·ªô N√£o C·ªßa Agent

Instructions (hay system prompt) kh√¥ng ch·ªâ l√† "h∆∞·ªõng d·∫´n s·ª≠ d·ª•ng" m√† c√≤n l√† **DNA** c·ªßa agent - ƒë·ªãnh nghƒ©a personality, capabilities, v√† behavior patterns. M·ªôt instruction t·ªët c√≥ th·ªÉ:

- **ƒê·ªãnh h∆∞·ªõng h√†nh vi**: Agent s·∫Ω ph·∫£n ·ª©ng nh∆∞ th·∫ø n√†o trong c√°c t√¨nh hu·ªëng kh√°c nhau
- **Thi·∫øt l·∫≠p context**: Vai tr√≤, expertise, v√† domain knowledge
- **ƒê·∫∑t ra boundaries**: Nh·ªØng g√¨ agent n√™n v√† kh√¥ng n√™n l√†m
- **C·∫£i thi·ªán accuracy**: Gi·∫£m hallucination v√† tƒÉng t√≠nh nh·∫•t qu√°n

### Tools - ƒê√¥i Tay C·ªßa Agent

Tools cho ph√©p agents:
- **Truy c·∫≠p d·ªØ li·ªáu real-time**: Weather, news, stock prices
- **T∆∞∆°ng t√°c v·ªõi services**: Send emails, create calendar events
- **X·ª≠ l√Ω files**: Read/write documents, analyze spreadsheets  
- **Th·ª±c hi·ªán calculations**: Complex math, data analysis
- **Control systems**: Automate workflows, manage infrastructure

## Vi·∫øt Instructions Hi·ªáu Qu·∫£

### C·∫•u Tr√∫c Instructions T·ªëi ∆Øu

```python
def create_expert_instructions(domain: str, role: str, constraints: list = None) -> str:
    """Template t·∫°o instructions chuy√™n nghi·ªáp"""
    
    constraints = constraints or []
    constraints_text = "\n".join([f"- {c}" for c in constraints])
    
    return f"""
# Role & Identity
You are a {role} specializing in {domain}.

# Core Responsibilities  
- Provide accurate, actionable advice
- Ask clarifying questions when requests are ambiguous
- Explain your reasoning step-by-step
- Admit when you're uncertain about something

# Communication Style
- Be professional yet approachable
- Use clear, concise language
- Provide examples when helpful
- Structure responses with headers and bullet points

# Constraints & Guidelines
{constraints_text}

# Quality Standards
- Always double-check facts and calculations
- Cite sources when making specific claims
- Focus on practical, implementable solutions
- Consider potential risks and alternatives
"""

# V√≠ d·ª• s·ª≠ d·ª•ng
financial_advisor_instructions = create_expert_instructions(
    domain="personal finance and investment",
    role="Senior Financial Advisor",
    constraints=[
        "Never provide specific stock recommendations",
        "Always mention risks associated with investments",
        "Suggest consulting with certified professionals for major decisions",
        "Focus on educational content rather than direct advice"
    ]
)
```

### Dynamic Instructions - Th√¥ng Minh H∆°n V·ªõi Context

```python
from datetime import datetime
from agents import Agent, RunContextWrapper

def dynamic_market_instructions(
    context: RunContextWrapper, 
    agent: Agent
) -> str:
    """Instructions thay ƒë·ªïi theo th·ªùi gian v√† context"""
    
    current_time = datetime.now()
    market_hours = 9 <= current_time.hour <= 16
    is_weekend = current_time.weekday() >= 5
    
    base_instructions = """
    You are a Financial Market Assistant with real-time market awareness.
    
    Your capabilities:
    - Analyze market trends and patterns
    - Explain financial concepts clearly
    - Provide educational market insights
    """
    
    # Th√™m context v·ªÅ th·ªùi gian
    time_context = f"""
    
    # Current Context
    - Current time: {current_time.strftime('%Y-%m-%d %H:%M %Z')}
    - Market status: {'OPEN' if market_hours and not is_weekend else 'CLOSED'}
    """
    
    if market_hours and not is_weekend:
        time_context += """
    - Focus on real-time market movements
    - Mention that data might be delayed
    - Emphasize volatility during trading hours
    """
    else:
        time_context += """
    - Focus on market analysis and education
    - Mention markets are currently closed
    - Discuss preparation for next trading session
    """
        
    return base_instructions + time_context

# S·ª≠ d·ª•ng dynamic instructions
market_agent = Agent(
    name="Market Assistant",
    instructions=dynamic_market_instructions,
    # tools s·∫Ω ƒë∆∞·ª£c th√™m sau
)
```

### Best Practices Cho Instructions

**‚úÖ DO - Nh·ªØng ƒêi·ªÅu N√™n L√†m:**

```python
good_instructions = """
# Role Definition
You are a Code Review Assistant for Python projects.

# Specific Tasks
1. Analyze code for bugs, security issues, and performance problems
2. Suggest improvements following PEP 8 and best practices
3. Explain the reasoning behind each suggestion
4. Provide code examples for recommended changes

# Response Format
For each file reviewed:
## Summary
- Overall code quality: [Score/10]
- Main issues found: [count]

## Detailed Feedback
### Critical Issues (Security/Bugs)
- [List critical issues with line numbers]

### Improvements (Performance/Style)  
- [List improvement suggestions]

### Positive Aspects
- [Highlight good practices found]

# Tone & Style
- Be constructive and encouraging
- Focus on education, not just criticism
- Provide rationale for suggestions
- Use technical terms appropriately
"""
```

**‚ùå DON'T - Nh·ªØng ƒêi·ªÅu Tr√°nh:**

```python
bad_instructions = """
Help with code.  # Too vague
Be smart.         # Meaningless
Don't be wrong.   # Negative framing
Do everything.    # Unrealistic scope
"""
```

## Function Tools - S·ª©c M·∫°nh Th·∫≠t S·ª±

### C√°ch Ho·∫°t ƒê·ªông C·ªßa Function Tools

OpenAI Agents SDK t·ª± ƒë·ªông:
1. **Extract function signature** t·ª´ Python function
2. **Generate JSON schema** cho parameters
3. **Parse docstring** ƒë·ªÉ l·∫•y descriptions
4. **Handle type validation** v·ªõi Pydantic
5. **Execute function** khi LLM g·ªçi tool

### Basic Function Tools

```python
import requests
from typing import Dict, Any
from agents import Agent, Runner, function_tool

@function_tool
def get_weather(city: str, country_code: str = "US") -> str:
    """Get current weather information for a specific city.
    
    Args:
        city: Name of the city (e.g., "New York", "London")
        country_code: ISO country code (e.g., "US", "UK", "VN")
        
    Returns:
        Weather information as a formatted string
    """
    # Demo implementation - trong th·ª±c t·∫ø s·∫Ω call real weather API
    try:
        # Mock weather data
        weather_data = {
            "temperature": 22,
            "condition": "Sunny",
            "humidity": 65,
            "wind_speed": 10
        }
        
        return f"""
Weather in {city}, {country_code}:
üå°Ô∏è Temperature: {weather_data['temperature']}¬∞C
‚òÄÔ∏è Condition: {weather_data['condition']}
üíß Humidity: {weather_data['humidity']}%
üí® Wind Speed: {weather_data['wind_speed']} km/h
        """.strip()
        
    except Exception as e:
        return f"Sorry, I couldn't fetch weather data for {city}. Error: {str(e)}"

@function_tool
def calculate_compound_interest(
    principal: float, 
    annual_rate: float, 
    years: int,
    compound_frequency: int = 12
) -> Dict[str, Any]:
    """Calculate compound interest over time.
    
    Args:
        principal: Initial investment amount in dollars
        annual_rate: Annual interest rate as decimal (e.g., 0.05 for 5%)
        years: Number of years to calculate
        compound_frequency: How many times per year interest compounds (default: 12 for monthly)
        
    Returns:
        Dictionary with calculation results
    """
    if principal <= 0 or annual_rate < 0 or years <= 0:
        return {"error": "Invalid input parameters"}
        
    # A = P(1 + r/n)^(nt)
    final_amount = principal * (1 + annual_rate/compound_frequency) ** (compound_frequency * years)
    total_interest = final_amount - principal
    
    return {
        "principal": principal,
        "annual_rate": annual_rate * 100,  # Convert to percentage
        "years": years,
        "compound_frequency": compound_frequency,
        "final_amount": round(final_amount, 2),
        "total_interest": round(total_interest, 2),
        "growth_percentage": round((total_interest / principal) * 100, 2)
    }

# T·∫°o agent v·ªõi tools
weather_finance_agent = Agent(
    name="Weather & Finance Assistant",
    instructions="""
    You are a helpful assistant that can provide weather information and financial calculations.
    
    Capabilities:
    - Get current weather for any city
    - Calculate compound interest for investments
    
    When providing financial calculations:
    - Always explain the assumptions used
    - Mention that this is for educational purposes
    - Suggest consulting with financial advisors for actual investment decisions
    
    Format your responses clearly with appropriate emojis and structure.
    """,
    tools=[get_weather, calculate_compound_interest]
)

# Test the agent
async def test_tools():
    # Weather query
    result1 = await Runner.run(
        weather_finance_agent,
        "What's the weather like in Hanoi, Vietnam?"
    )
    print("Weather Query Result:")
    print(result1.final_output)
    print("\n" + "="*50 + "\n")
    
    # Finance query  
    result2 = await Runner.run(
        weather_finance_agent,
        "If I invest $10,000 at 7% annual interest for 20 years, how much will I have?"
    )
    print("Finance Query Result:")
    print(result2.final_output)

if __name__ == "__main__":
    import asyncio
    asyncio.run(test_tools())
```

### Advanced Function Tools v·ªõi Context

```python
from dataclasses import dataclass
from typing import List, Optional
from agents import RunContextWrapper, function_tool

@dataclass
class UserProfile:
    user_id: str
    name: str
    email: str
    preferences: Dict[str, Any]
    subscription_level: str = "basic"

@function_tool
async def get_user_preferences(
    ctx: RunContextWrapper[UserProfile], 
    category: str
) -> Dict[str, Any]:
    """Get user preferences for a specific category.
    
    Args:
        category: Category of preferences (e.g., 'notifications', 'display', 'privacy')
        
    Returns:
        User preferences for the specified category
    """
    user = ctx.context
    
    # Simulate database lookup
    all_preferences = {
        "notifications": {
            "email": user.subscription_level != "basic",
            "push": True,
            "frequency": "daily" if user.subscription_level == "premium" else "weekly"
        },
        "display": {
            "theme": "dark",
            "language": "en",
            "timezone": "Asia/Ho_Chi_Minh"
        },
        "privacy": {
            "analytics": user.subscription_level == "premium",
            "data_sharing": False
        }
    }
    
    return {
        "user_id": user.user_id,
        "category": category,
        "preferences": all_preferences.get(category, {}),
        "subscription_level": user.subscription_level
    }

@function_tool
async def update_user_preferences(
    ctx: RunContextWrapper[UserProfile],
    category: str,
    updates: Dict[str, Any]
) -> str:
    """Update user preferences for a specific category.
    
    Args:
        category: Category to update
        updates: Dictionary of preference updates
        
    Returns:
        Confirmation message
    """
    user = ctx.context
    
    # Validate subscription level for premium features
    if category == "notifications" and updates.get("frequency") == "realtime":
        if user.subscription_level != "premium":
            return "Real-time notifications require a Premium subscription. Please upgrade to access this feature."
    
    # Simulate database update
    print(f"Updating {category} preferences for user {user.name}")
    print(f"Updates: {updates}")
    
    return f"Successfully updated {category} preferences for {user.name}. Changes will take effect immediately."

# Context-aware agent
personalized_agent = Agent[UserProfile](
    name="Personal Settings Assistant",
    instructions="""
    You are a personal settings assistant that helps users manage their account preferences.
    
    You have access to the user's profile and can:
    - Retrieve current preferences by category
    - Update preferences based on user requests
    - Explain subscription-level restrictions
    
    Always:
    - Address the user by name
    - Explain what changes were made
    - Mention subscription limitations when relevant
    - Ask for confirmation before making changes
    """,
    tools=[get_user_preferences, update_user_preferences]
)

# Usage example
async def demo_context_tools():
    # Create user profile
    user = UserProfile(
        user_id="user_123",
        name="Alice",
        email="alice@example.com",
        preferences={},
        subscription_level="basic"
    )
    
    # Test the agent
    result = await Runner.run(
        personalized_agent,
        "Can you show me my notification settings and help me enable real-time notifications?",
        context=user
    )
    
    print(result.final_output)

if __name__ == "__main__":
    import asyncio
    asyncio.run(demo_context_tools())
```

### Custom Function Tools - Ki·ªÉm So√°t Ho√†n To√†n

```python
from pydantic import BaseModel
from agents import FunctionTool, RunContextWrapper

class DatabaseQuery(BaseModel):
    table: str
    where_clause: Optional[str] = None
    limit: int = 10

async def execute_safe_query(ctx: RunContextWrapper, args: str) -> str:
    """Execute a database query with safety checks"""
    try:
        query_params = DatabaseQuery.model_validate_json(args)
        
        # Safety checks
        dangerous_keywords = ['DROP', 'DELETE', 'UPDATE', 'INSERT', 'TRUNCATE']
        if query_params.where_clause:
            if any(keyword in query_params.where_clause.upper() for keyword in dangerous_keywords):
                return "Error: Dangerous SQL keywords detected. Only SELECT queries are allowed."
        
        # Simulate database query
        mock_results = [
            {"id": 1, "name": "Product A", "price": 29.99},
            {"id": 2, "name": "Product B", "price": 49.99},
        ]
        
        return f"Query Results from {query_params.table}:\n" + \
               "\n".join([str(row) for row in mock_results[:query_params.limit]])
               
    except Exception as e:
        return f"Query execution error: {str(e)}"

# Create custom tool
database_tool = FunctionTool(
    name="query_database",
    description="Execute safe SELECT queries on the database",
    params_json_schema=DatabaseQuery.model_json_schema(),
    on_invoke_tool=execute_safe_query,
)

# Agent with custom tool
database_agent = Agent(
    name="Database Assistant",
    instructions="""
    You are a database assistant that can help users query data safely.
    
    Security restrictions:
    - Only SELECT queries are allowed
    - No modification operations (INSERT, UPDATE, DELETE, DROP)
    - Query results are limited to prevent overload
    
    Always explain what data you're retrieving and why.
    """,
    tools=[database_tool]
)
```

### Error Handling trong Function Tools

```python
from agents import function_tool

@function_tool(failure_error_function=None)  # Re-raise errors for custom handling
def risky_api_call(endpoint: str) -> str:
    """Call external API with proper error handling.
    
    Args:
        endpoint: API endpoint to call
        
    Returns:
        API response data
    """
    try:
        # Simulate API call
        if "invalid" in endpoint:
            raise ValueError("Invalid endpoint format")
            
        if "timeout" in endpoint:
            raise TimeoutError("API request timed out")
            
        return f"Success: Data from {endpoint}"
        
    except ValueError as e:
        return f"Validation Error: {str(e)}"
    except TimeoutError as e:
        return f"Timeout Error: {str(e)}. Please try again later."
    except Exception as e:
        return f"Unexpected Error: {str(e)}"

def custom_error_handler(error: Exception, tool_name: str, args: str) -> str:
    """Custom error handler for tools"""
    return f"The {tool_name} tool encountered an issue. Please try rephrasing your request or contact support if the problem persists."

@function_tool(failure_error_function=custom_error_handler)
def another_tool(data: str) -> str:
    """Another tool with custom error handling"""
    if not data:
        raise ValueError("Data cannot be empty")
    return f"Processed: {data}"
```

## Real-World Example: Smart Task Manager

H√£y x√¢y d·ª±ng m·ªôt task manager th√¥ng minh v·ªõi ƒë·∫ßy ƒë·ªß t√≠nh nƒÉng:

```python
import json
from datetime import datetime, timedelta
from typing import List, Dict, Optional
from enum import Enum
from pydantic import BaseModel
from agents import Agent, Runner, function_tool

class Priority(str, Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    URGENT = "urgent"

class TaskStatus(str, Enum):
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    CANCELLED = "cancelled"

class Task(BaseModel):
    id: str
    title: str
    description: Optional[str] = None
    priority: Priority = Priority.MEDIUM
    status: TaskStatus = TaskStatus.PENDING
    due_date: Optional[str] = None
    created_at: str
    tags: List[str] = []

# In-memory storage (trong production s·∫Ω d√πng database)
tasks_storage: Dict[str, Task] = {}

@function_tool
def create_task(
    title: str,
    description: str = "",
    priority: str = "medium",
    due_date: str = "",
    tags: str = ""
) -> str:
    """Create a new task.
    
    Args:
        title: Task title
        description: Detailed description
        priority: Task priority (low, medium, high, urgent)
        due_date: Due date in YYYY-MM-DD format
        tags: Comma-separated tags
        
    Returns:
        Confirmation message with task ID
    """
    try:
        task_id = f"task_{len(tasks_storage) + 1}"
        tag_list = [tag.strip() for tag in tags.split(",") if tag.strip()]
        
        task = Task(
            id=task_id,
            title=title,
            description=description,
            priority=Priority(priority.lower()),
            due_date=due_date if due_date else None,
            created_at=datetime.now().isoformat(),
            tags=tag_list
        )
        
        tasks_storage[task_id] = task
        
        return f"""‚úÖ Task created successfully!
        
**Task ID:** {task_id}
**Title:** {title}
**Priority:** {priority.upper()}
**Due Date:** {due_date or 'Not set'}
**Tags:** {', '.join(tag_list) if tag_list else 'None'}

You can reference this task using ID: {task_id}"""

    except Exception as e:
        return f"‚ùå Error creating task: {str(e)}"

@function_tool
def list_tasks(
    status: str = "all",
    priority: str = "all",
    limit: int = 10
) -> str:
    """List tasks with optional filtering.
    
    Args:
        status: Filter by status (all, pending, in_progress, completed, cancelled)
        priority: Filter by priority (all, low, medium, high, urgent)
        limit: Maximum number of tasks to return
        
    Returns:
        Formatted list of tasks
    """
    try:
        filtered_tasks = list(tasks_storage.values())
        
        # Filter by status
        if status != "all":
            filtered_tasks = [t for t in filtered_tasks if t.status.value == status]
            
        # Filter by priority
        if priority != "all":
            filtered_tasks = [t for t in filtered_tasks if t.priority.value == priority]
            
        # Sort by priority and due date
        priority_order = {"urgent": 4, "high": 3, "medium": 2, "low": 1}
        filtered_tasks.sort(
            key=lambda t: (
                priority_order.get(t.priority.value, 0),
                t.due_date or "9999-12-31"
            ),
            reverse=True
        )
        
        if not filtered_tasks:
            return "üìù No tasks found matching your criteria."
            
        result = f"üìã **Task List** (showing {min(len(filtered_tasks), limit)} of {len(filtered_tasks)} tasks)\n\n"
        
        for task in filtered_tasks[:limit]:
            priority_emoji = {
                "urgent": "üî•",
                "high": "‚ö°",
                "medium": "üìù",
                "low": "üí§"
            }
            
            status_emoji = {
                "pending": "‚è≥",
                "in_progress": "üîÑ",
                "completed": "‚úÖ",
                "cancelled": "‚ùå"
            }
            
            due_info = f" (Due: {task.due_date})" if task.due_date else ""
            tags_info = f" #{', #'.join(task.tags)}" if task.tags else ""
            
            result += f"{priority_emoji.get(task.priority.value, 'üìù')} **{task.title}** [{task.id}]\n"
            result += f"{status_emoji.get(task.status.value, '‚è≥')} {task.status.value.replace('_', ' ').title()}{due_info}\n"
            if task.description:
                result += f"üí≠ {task.description}\n"
            if tags_info:
                result += f"üè∑Ô∏è {tags_info}\n"
            result += "\n"
            
        return result.strip()
        
    except Exception as e:
        return f"‚ùå Error listing tasks: {str(e)}"

@function_tool
def update_task_status(task_id: str, new_status: str) -> str:
    """Update task status.
    
    Args:
        task_id: Task ID to update
        new_status: New status (pending, in_progress, completed, cancelled)
        
    Returns:
        Confirmation message
    """
    try:
        if task_id not in tasks_storage:
            return f"‚ùå Task {task_id} not found."
            
        old_status = tasks_storage[task_id].status.value
        tasks_storage[task_id].status = TaskStatus(new_status.lower())
        
        status_emoji = {
            "pending": "‚è≥",
            "in_progress": "üîÑ", 
            "completed": "‚úÖ",
            "cancelled": "‚ùå"
        }
        
        return f"{status_emoji.get(new_status.lower(), 'üìù')} Task **{tasks_storage[task_id].title}** status updated from {old_status} to {new_status}!"
        
    except Exception as e:
        return f"‚ùå Error updating task: {str(e)}"

@function_tool
def get_task_analytics() -> str:
    """Get task analytics and insights.
    
    Returns:
        Task statistics and insights
    """
    try:
        if not tasks_storage:
            return "üìä No tasks available for analysis."
            
        total_tasks = len(tasks_storage)
        status_counts = {}
        priority_counts = {}
        overdue_count = 0
        
        today = datetime.now().date()
        
        for task in tasks_storage.values():
            # Count by status
            status_counts[task.status.value] = status_counts.get(task.status.value, 0) + 1
            
            # Count by priority
            priority_counts[task.priority.value] = priority_counts.get(task.priority.value, 0) + 1
            
            # Check overdue
            if task.due_date and task.status != TaskStatus.COMPLETED:
                due_date = datetime.strptime(task.due_date, "%Y-%m-%d").date()
                if due_date < today:
                    overdue_count += 1
                    
        completion_rate = (status_counts.get("completed", 0) / total_tasks) * 100
        
        result = f"""üìä **Task Analytics**

**Overview:**
‚Ä¢ Total Tasks: {total_tasks}
‚Ä¢ Completion Rate: {completion_rate:.1f}%
‚Ä¢ Overdue Tasks: {overdue_count}

**By Status:**
"""
        for status, count in status_counts.items():
            percentage = (count / total_tasks) * 100
            result += f"‚Ä¢ {status.replace('_', ' ').title()}: {count} ({percentage:.1f}%)\n"
            
        result += "\n**By Priority:**\n"
        for priority, count in priority_counts.items():
            percentage = (count / total_tasks) * 100
            result += f"‚Ä¢ {priority.title()}: {count} ({percentage:.1f}%)\n"
            
        # Insights
        result += "\n**üí° Insights:**\n"
        if overdue_count > 0:
            result += f"‚Ä¢ ‚ö†Ô∏è You have {overdue_count} overdue task(s) that need attention\n"
        if priority_counts.get("urgent", 0) > 2:
            result += f"‚Ä¢ üî• High number of urgent tasks - consider prioritizing\n"
        if completion_rate < 50:
            result += f"‚Ä¢ üìà Low completion rate - try breaking down large tasks\n"
        else:
            result += f"‚Ä¢ üéâ Good job! You're maintaining a healthy completion rate\n"
            
        return result
        
    except Exception as e:
        return f"‚ùå Error generating analytics: {str(e)}"

# Create the Smart Task Manager Agent
task_manager_agent = Agent(
    name="Smart Task Manager",
    instructions="""
    You are an intelligent task management assistant that helps users organize and track their work efficiently.
    
    # Your Capabilities
    - Create new tasks with proper categorization
    - List and filter existing tasks  
    - Update task statuses
    - Provide analytics and insights
    
    # Communication Style
    - Be proactive in suggesting task organization improvements
    - Use emojis and formatting to make responses visually appealing
    - Provide actionable insights based on task data
    - Ask clarifying questions when task details are incomplete
    
    # Best Practices
    - Suggest appropriate priorities based on due dates and descriptions
    - Recommend breaking down large tasks into smaller ones
    - Alert users about overdue tasks
    - Celebrate completed milestones
    
    # When creating tasks:
    - Ask about due dates if not provided
    - Suggest relevant tags based on task content
    - Recommend appropriate priority levels
    
    # When providing analytics:
    - Give actionable insights
    - Highlight both achievements and areas for improvement
    - Suggest specific next actions
    """,
    tools=[create_task, list_tasks, update_task_status, get_task_analytics]
)

# Demo the Smart Task Manager
async def demo_task_manager():
    print("üöÄ Smart Task Manager Demo\n")
    
    # Create some sample tasks
    queries = [
        "Create a task to 'Review Q4 budget proposal' with high priority, due 2025-02-01, tags: finance, budget",
        "Add a task 'Buy groceries' with medium priority and tag: personal",
        "Create an urgent task 'Fix production bug in payment system' due tomorrow",
        "Show me all my tasks",
        "Mark the payment system bug as in progress",
        "Give me task analytics and insights"
    ]
    
    for i, query in enumerate(queries, 1):
        print(f"**Query {i}:** {query}")
        result = await Runner.run(task_manager_agent, query)
        print(f"**Response:**\n{result.final_output}\n")
        print("-" * 80 + "\n")

if __name__ == "__main__":
    import asyncio
    asyncio.run(demo_task_manager())
```

## T·ªïng K·∫øt v√† Best Practices

### Nh·ªØng ƒêi·ªÅu C·∫ßn Ghi Nh·ªõ

‚úÖ **Instructions l√† foundation** - ƒê·∫ßu t∆∞ th·ªùi gian vi·∫øt instructions chi ti·∫øt v√† r√µ r√†ng  
‚úÖ **Tools m·ªü r·ªông capabilities** - Function tools cho ph√©p agents t∆∞∆°ng t√°c v·ªõi th·∫ø gi·ªõi th·ª±c  
‚úÖ **Type hints v√† docstrings** - SDK t·ª± ƒë·ªông generate schemas t·ª´ Python code  
‚úÖ **Error handling** - Lu√¥n handle errors gracefully trong tools  
‚úÖ **Context awareness** - S·ª≠ d·ª•ng dynamic instructions v√† context-aware tools  

### Production Checklist

üîç **Instructions Quality:**
- [ ] Vai tr√≤ v√† tr√°ch nhi·ªám ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a r√µ r√†ng
- [ ] Phong c√°ch giao ti·∫øp ƒë∆∞·ª£c thi·∫øt l·∫≠p
- [ ] C√°c gi·ªõi h·∫°n v√† h·∫°n ch·∫ø ƒë∆∞·ª£c n√™u r√µ
- [ ] Ti√™u chu·∫©n ch·∫•t l∆∞·ª£ng ƒë∆∞·ª£c x√°c ƒë·ªãnh

üõ†Ô∏è **Tools Development:**
- [ ] Function signatures c√≥ type hints ƒë·∫ßy ƒë·ªß
- [ ] Docstrings m√¥ t·∫£ parameters v√† return values
- [ ] Error handling to√†n di·ªán
- [ ] Input validation v√† sanitization
- [ ] T·ªëi ∆∞u hi·ªáu su·∫•t cho tools th∆∞·ªùng d√πng

### B∆∞·ªõc Ti·∫øp Theo

Trong **b√†i ti·∫øp theo**, ch√∫ng ta s·∫Ω kh√°m ph√°:

üéØ **Context Management** - Qu·∫£n l√Ω data v√† dependencies hi·ªáu qu·∫£  
üìä **State Management** - Duy tr√¨ state xuy√™n su·ªët conversations  
üîÑ **Data Flow Patterns** - Best practices cho data handling  

### Th·ª≠ Th√°ch Cho B·∫°n

Tr∆∞·ªõc khi chuy·ªÉn b√†i ti·∫øp theo:

1. **Extend Task Manager** v·ªõi reminder notifications
2. **Create domain-specific agent** cho work c·ªßa b·∫°n
3. **Experiment v·ªõi different instruction styles** v√† measure effectiveness

---

*B√†i ti·∫øp theo: [**"Context Management: Qu·∫£n L√Ω D·ªØ Li·ªáu v√† Dependencies Trong Agents"**](../openai-agents-sdk-part-03-context-management-data-dependencies/) - Ch√∫ng ta s·∫Ω h·ªçc c√°ch qu·∫£n l√Ω state, data flow, v√† dependencies ƒë·ªÉ x√¢y d·ª±ng agents th·ª±c s·ª± th√¥ng minh.*