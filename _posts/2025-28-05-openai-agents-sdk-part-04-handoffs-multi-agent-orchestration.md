---
title: "Handoffs: Orchestrating Multiple Agents nh∆∞ m·ªôt D√†n Nh·∫°c"
date: 2025-05-23 09:00:00 +0700
categories: [AI, OpenAI]
tags: [openai, agents, handoffs, multi-agent, orchestration]
author: toantranct
description: H∆∞·ªõng d·∫´n chi ti·∫øt v·ªÅ Handoffs trong OpenAI Agents SDK. T·ª´ basic delegation ƒë·∫øn advanced multi-agent orchestration patterns v·ªõi real-world examples.
---

Trong nh·ªØng b√†i tr∆∞·ªõc, ch√∫ng ta ƒë√£ h·ªçc c√°ch t·∫°o agents v·ªõi tools v√† qu·∫£n l√Ω context. Nh∆∞ng trong th·∫ø gi·ªõi th·ª±c, m·ªôt agent duy nh·∫•t - d√π c√≥ m·∫°nh m·∫Ω ƒë·∫øn ƒë√¢u - c≈©ng kh√¥ng th·ªÉ gi·∫£i quy·∫øt m·ªçi v·∫•n ƒë·ªÅ ph·ª©c t·∫°p. ƒê√≥ l√† l√∫c ch√∫ng ta c·∫ßn **Handoffs** - kh·∫£ nƒÉng cho ph√©p c√°c agents ph·ªëi h·ª£p v√† ·ªßy quy·ªÅn cho nhau nh∆∞ m·ªôt d√†n nh·∫°c ho√†n h·∫£o.

Handoffs kh√¥ng ch·ªâ l√† vi·ªác "chuy·ªÉn giao c√¥ng vi·ªác", m√† l√† ngh·ªá thu·∫≠t **orchestration** - bi·∫øt khi n√†o c·∫ßn chuy√™n gia, l√†m th·∫ø n√†o ƒë·ªÉ truy·ªÅn ƒë·∫°t context, v√† ƒë·∫£m b·∫£o workflow m∆∞·ª£t m√†. H√¥m nay, ch√∫ng ta s·∫Ω kh√°m ph√° c√°ch x√¢y d·ª±ng nh·ªØng h·ªá th·ªëng multi-agent th√¥ng minh v√† hi·ªáu qu·∫£.

## T·∫°i Sao C·∫ßn Handoffs?

### Th·∫ø Gi·ªõi Th·ª±c Ho·∫°t ƒê·ªông Nh∆∞ Th·∫ø N√†o

H√£y t∆∞·ªüng t∆∞·ª£ng b·∫°n g·ªçi v√†o m·ªôt c√¥ng ty l·ªõn:

1. **T·ªïng ƒë√†i** ti·∫øp nh·∫≠n v√† ph√¢n lo·∫°i y√™u c·∫ßu
2. **Chuy√™n vi√™n k·ªπ thu·∫≠t** x·ª≠ l√Ω v·∫•n ƒë·ªÅ technical
3. **Qu·∫£n l√Ω** x·ª≠ l√Ω c√°c v·∫•n ƒë·ªÅ ph·ª©c t·∫°p
4. **Chuy√™n vi√™n thanh to√°n** x·ª≠ l√Ω billing issues

M·ªói ng∆∞·ªùi c√≥ expertise ri√™ng, nh∆∞ng h·ªç ph·ªëi h·ª£p ƒë·ªÉ gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ c·ªßa b·∫°n m·ªôt c√°ch hi·ªáu qu·∫£ nh·∫•t.

### Single Agent vs Multi-Agent Architecture

**ü§ñ Single Agent Approach:**
```
User Request ‚Üí Generalist Agent ‚Üí Response
```

**V·∫•n ƒë·ªÅ:**
- Agent ph·∫£i "bi·∫øt t·∫•t c·∫£" ‚Üí performance k√©m
- Context switching gi·ªØa c√°c domains kh√°c nhau
- Kh√≥ maintain v√† improve t·ª´ng area c·ª• th·ªÉ
- Kh√¥ng t·∫≠n d·ª•ng ƒë∆∞·ª£c specialized knowledge

**üé≠ Multi-Agent v·ªõi Handoffs:**
```
User Request ‚Üí Triage Agent ‚Üí Specialist Agent A ‚Üí Response
                           ‚Üí Specialist Agent B ‚Üí Response
                           ‚Üí Escalation Agent ‚Üí Response
```

**L·ª£i √≠ch:**
- M·ªói agent focus v√†o m·ªôt domain c·ª• th·ªÉ
- Better performance v√† accuracy
- Easier maintenance v√† scalability
- Natural division of concerns

### Use Cases Ph·ªï Bi·∫øn

üè¢ **Customer Service System:**
- Triage Agent ‚Üí Booking Agent / Refund Agent / FAQ Agent

üîç **Research Platform:**
- Research Coordinator ‚Üí Data Collector / Analyst / Report Writer

‚öïÔ∏è **Healthcare Assistant:**
- Intake Agent ‚Üí Symptom Checker / Appointment Scheduler / Emergency Handler

üíº **Business Process Automation:**
- Process Manager ‚Üí Document Processor / Email Handler / Database Manager

## Handoffs C∆° B·∫£n

### C√°ch Ho·∫°t ƒê·ªông

Handoffs trong OpenAI Agents SDK ho·∫°t ƒë·ªông b·∫±ng c√°ch bi·∫øn ch√∫ng th√†nh **tools** m√† LLM c√≥ th·ªÉ g·ªçi. N·∫øu c√≥ handoff ƒë·∫øn agent t√™n "Refund Agent", tool s·∫Ω c√≥ t√™n `transfer_to_refund_agent`.

### T·∫°o Handoff ƒê∆°n Gi·∫£n

```python
from agents import Agent, Runner

# T·∫°o specialized agents
billing_agent = Agent(
    name="Billing Agent",
    instructions="""
    You are a billing specialist for TechCorp.
    
    Expertise:
    - Invoice questions and disputes
    - Payment processing issues
    - Subscription management
    - Billing history inquiries
    
    Always:
    - Ask for account number or email for verification
    - Provide clear explanations of charges
    - Offer solutions, not just explanations
    - Be empathetic with billing concerns
    """
)

refund_agent = Agent(
    name="Refund Agent", 
    instructions="""
    You are a refund specialist for TechCorp.
    
    Expertise:
    - Processing refund requests
    - Determining refund eligibility
    - Explaining refund policies
    - Handling special cases and escalations
    
    Refund Policy Guidelines:
    - Full refund within 30 days for unused services
    - Partial refund for partially used services
    - No refund for services used > 30 days (exceptions apply)
    - Always explain the reasoning behind decisions
    """
)

# Triage agent v·ªõi handoffs
triage_agent = Agent(
    name="Customer Service Triage",
    instructions="""
    You are the first point of contact for customer service.
    
    Your role:
    - Understand customer inquiries
    - Route to appropriate specialists
    - Handle simple questions yourself when possible
    
    Routing Guidelines:
    - Billing questions, payment issues ‚Üí Billing Agent
    - Refund requests, return policies ‚Üí Refund Agent
    - General questions ‚Üí Handle yourself
    
    Always be friendly and explain why you're transferring them.
    """,
    handoffs=[billing_agent, refund_agent]  # Basic handoff setup
)

# Test basic handoffs
async def test_basic_handoffs():
    queries = [
        "I have a question about my last invoice",
        "I want to request a refund for my subscription", 
        "What are your business hours?"
    ]
    
    for query in queries:
        print(f"**Customer:** {query}")
        result = await Runner.run(triage_agent, query)
        print(f"**Response:** {result.final_output}")
        print(f"**Last Agent:** {result.last_agent.name}\n")

if __name__ == "__main__":
    import asyncio
    asyncio.run(test_basic_handoffs())
```

## Advanced Handoffs v·ªõi Customization

### Handoff v·ªõi Input Data

Th∆∞·ªùng th√¨ khi handoff, ch√∫ng ta mu·ªën truy·ªÅn th√™m th√¥ng tin c·ª• th·ªÉ:

```python
from pydantic import BaseModel
from agents import Agent, handoff, RunContextWrapper

class EscalationData(BaseModel):
    reason: str
    customer_priority: str
    issue_summary: str
    attempted_solutions: list[str]

class TicketData(BaseModel):
    ticket_id: str
    category: str
    urgency: str
    customer_info: str

async def on_escalation_handoff(ctx: RunContextWrapper[None], input_data: EscalationData):
    """Callback khi escalation x·∫£y ra"""
    print(f"üö® ESCALATION ALERT:")
    print(f"   Reason: {input_data.reason}")
    print(f"   Priority: {input_data.customer_priority}")
    print(f"   Summary: {input_data.issue_summary}")
    
    # C√≥ th·ªÉ g·ª≠i notification, log, etc.
    # await send_slack_notification(input_data)
    # await create_high_priority_ticket(input_data)

async def on_technical_handoff(ctx: RunContextWrapper[None], input_data: TicketData):
    """Callback cho technical handoffs"""
    print(f"üîß Technical Support Handoff:")
    print(f"   Ticket: {input_data.ticket_id}")
    print(f"   Category: {input_data.category}")
    print(f"   Urgency: {input_data.urgency}")

# Advanced agents v·ªõi custom handoffs
escalation_agent = Agent(
    name="Escalation Manager",
    instructions="""
    You are a senior customer service manager handling escalated issues.
    
    Expertise:
    - Complex problem resolution
    - Policy exceptions and special cases
    - Customer retention strategies
    - Interdepartmental coordination
    
    When you receive an escalation:
    1. Acknowledge the customer's frustration
    2. Review all attempted solutions
    3. Take ownership of the resolution
    4. Provide timeline for resolution
    5. Follow up personally
    """
)

technical_agent = Agent(
    name="Technical Support Specialist", 
    instructions="""
    You are a technical support specialist.
    
    Expertise:
    - Software troubleshooting
    - API integration issues
    - Performance optimization
    - System configuration
    
    Approach:
    1. Gather detailed technical information
    2. Reproduce the issue when possible
    3. Provide step-by-step solutions
    4. Verify resolution with customer
    5. Document solution for future reference
    """
)

# Advanced triage v·ªõi custom handoffs
advanced_triage_agent = Agent(
    name="Advanced Customer Service",
    instructions="""
    You are an intelligent customer service coordinator.
    
    Capabilities:
    - Assess issue complexity and urgency
    - Route to most appropriate specialist
    - Gather necessary information before handoff
    - Handle simple issues independently
    
    Handoff Decision Matrix:
    - Technical issues (API, integration, bugs) ‚Üí Technical Support
    - Billing disputes, complex refunds ‚Üí Escalation Manager
    - Standard questions ‚Üí Handle yourself
    
    Always gather relevant details before handoff to make the specialist's job easier.
    """,
    handoffs=[
        handoff(
            agent=escalation_agent,
            on_handoff=on_escalation_handoff,
            input_type=EscalationData,
            tool_name_override="escalate_to_manager",
            tool_description_override="Escalate complex issues to senior management"
        ),
        handoff(
            agent=technical_agent,
            on_handoff=on_technical_handoff,
            input_type=TicketData,
            tool_name_override="transfer_to_technical_support",
            tool_description_override="Transfer technical issues to specialized support"
        )
    ]
)

# Demo advanced handoffs
async def demo_advanced_handoffs():
    scenarios = [
        "Our API integration has been failing for 3 days and it's affecting our production system. We've tried restarting services but nothing works.",
        "I've been trying to get a refund for 2 weeks and nobody has helped me. I want to speak to a manager immediately.",
        "What's the difference between your Pro and Enterprise plans?"
    ]
    
    for scenario in scenarios:
        print(f"**Customer Issue:** {scenario}")
        result = await Runner.run(advanced_triage_agent, scenario)
        print(f"**Agent Response:** {result.final_output}")
        print(f"**Final Handler:** {result.last_agent.name}")
        print("-" * 80 + "\n")

if __name__ == "__main__":
    import asyncio
    asyncio.run(demo_advanced_handoffs())
```

### Input Filters - Ki·ªÉm So√°t Context Flow

Input filters cho ph√©p b·∫°n ki·ªÉm so√°t th√¥ng tin n√†o ƒë∆∞·ª£c truy·ªÅn ƒë·∫øn agent ti·∫øp theo:

```python
from agents import Agent, handoff
from agents.extensions import handoff_filters
from agents.handoffs import HandoffInputData

def custom_security_filter(input_data: HandoffInputData) -> HandoffInputData:
    """Remove sensitive information before handoff"""
    filtered_input = input_data.copy()
    
    # Remove any messages containing sensitive keywords
    sensitive_keywords = ['password', 'ssn', 'credit card', 'api key']
    
    filtered_messages = []
    for item in filtered_input.input:
        if isinstance(item, dict) and 'content' in item:
            content = item['content'].lower()
            if not any(keyword in content for keyword in sensitive_keywords):
                filtered_messages.append(item)
            else:
                # Replace with sanitized message
                sanitized_item = item.copy()
                sanitized_item['content'] = "[SENSITIVE INFORMATION REMOVED FOR SECURITY]"
                filtered_messages.append(sanitized_item)
        else:
            filtered_messages.append(item)
    
    filtered_input.input = filtered_messages
    return filtered_input

def context_summarizer_filter(input_data: HandoffInputData) -> HandoffInputData:
    """Summarize long conversations before handoff"""
    if len(input_data.input) > 10:  # If conversation is too long
        # Keep first message (context) and last 3 messages (recent context)
        filtered_input = input_data.copy()
        filtered_input.input = (
            input_data.input[:1] +  # Original context
            [{"role": "system", "content": "[CONVERSATION SUMMARY: Customer has been discussing billing issues for 15+ messages]"}] +
            input_data.input[-3:]   # Recent messages
        )
        return filtered_input
    return input_data

# Agents v·ªõi input filters
secure_billing_agent = Agent(
    name="Secure Billing Specialist",
    instructions="""
    You are a billing specialist with strict security protocols.
    
    Security Guidelines:
    - Never ask for sensitive information like SSN or full credit card numbers
    - Use last 4 digits for verification only
    - Redirect sensitive requests to secure channels
    - Log all security-related interactions
    """
)

# Handoff v·ªõi security filter
secure_triage_agent = Agent(
    name="Security-Conscious Triage",
    instructions="""
    You are a security-conscious customer service agent.
    Route billing issues to billing specialists with appropriate security measures.
    """,
    handoffs=[
        handoff(
            agent=secure_billing_agent,
            input_filter=custom_security_filter,
            tool_description_override="Transfer to secure billing specialist"
        )
    ]
)
```

## Real-World Example: Smart E-commerce Support

H√£y x√¢y d·ª±ng m·ªôt h·ªá th·ªëng customer support ho√†n ch·ªânh cho e-commerce:

```python
import json
from datetime import datetime, timedelta
from typing import Dict, Any, List, Optional
from pydantic import BaseModel
from agents import Agent, handoff, function_tool, RunContextWrapper

# Data models
class OrderInfo(BaseModel):
    order_id: str
    status: str
    items: List[Dict[str, Any]]
    total: float
    shipping_address: str

class CustomerProfile(BaseModel):
    customer_id: str
    name: str
    email: str
    tier: str  # bronze, silver, gold, platinum
    order_history: List[str]

# Mock data storage
ORDERS_DB = {
    "ORD-12345": {
        "order_id": "ORD-12345",
        "status": "shipped",
        "items": [{"name": "Wireless Headphones", "price": 99.99, "qty": 1}],
        "total": 99.99,
        "shipping_address": "123 Main St, City, State",
        "tracking_number": "TRK-789456"
    }
}

CUSTOMERS_DB = {
    "CUST-789": {
        "customer_id": "CUST-789",
        "name": "Alice Johnson",
        "email": "alice@example.com", 
        "tier": "gold",
        "order_history": ["ORD-12345", "ORD-11111"]
    }
}

# Shared context for all agents
class EcommerceContext:
    def __init__(self):
        self.current_customer: Optional[CustomerProfile] = None
        self.current_order: Optional[OrderInfo] = None
        self.session_notes: List[str] = []
    
    def add_note(self, note: str):
        self.session_notes.append(f"[{datetime.now().strftime('%H:%M')}] {note}")

# Tools for order management
@function_tool
async def lookup_order(
    ctx: RunContextWrapper[EcommerceContext], 
    order_id: str
) -> str:
    """Look up order information by order ID."""
    order_data = ORDERS_DB.get(order_id)
    
    if not order_data:
        return f"‚ùå Order {order_id} not found. Please check the order ID and try again."
    
    ctx.context.current_order = OrderInfo(**order_data)
    ctx.context.add_note(f"Retrieved order {order_id}")
    
    return f"""
üì¶ **Order Information: {order_id}**

‚Ä¢ **Status:** {order_data['status'].title()}
‚Ä¢ **Items:** {', '.join([f"{item['name']} (${item['price']})" for item in order_data['items']])}
‚Ä¢ **Total:** ${order_data['total']}
‚Ä¢ **Shipping Address:** {order_data['shipping_address']}
‚Ä¢ **Tracking:** {order_data.get('tracking_number', 'Not available')}
"""

@function_tool
async def lookup_customer(
    ctx: RunContextWrapper[EcommerceContext],
    customer_email: str
) -> str:
    """Look up customer profile by email."""
    # Simple lookup by email
    customer_data = None
    for customer in CUSTOMERS_DB.values():
        if customer['email'].lower() == customer_email.lower():
            customer_data = customer
            break
    
    if not customer_data:
        return f"‚ùå Customer with email {customer_email} not found."
    
    ctx.context.current_customer = CustomerProfile(**customer_data)
    ctx.context.add_note(f"Retrieved customer profile for {customer_data['name']}")
    
    return f"""
üë§ **Customer Profile**

‚Ä¢ **Name:** {customer_data['name']}
‚Ä¢ **Email:** {customer_data['email']}
‚Ä¢ **Tier:** {customer_data['tier'].title()}
‚Ä¢ **Order History:** {len(customer_data['order_history'])} orders
"""

# Specialized agents
order_tracking_agent = Agent[EcommerceContext](
    name="Order Tracking Specialist",
    instructions="""
    You are an order tracking specialist for ShopSmart e-commerce.
    
    Expertise:
    - Order status inquiries
    - Shipping and delivery updates
    - Tracking number assistance
    - Delivery issue resolution
    
    Process:
    1. Get order ID from customer
    2. Look up order information
    3. Provide detailed status update
    4. Offer proactive solutions for delays
    5. Set expectations for delivery
    
    Be proactive about potential issues and always provide tracking numbers when available.
    """,
    tools=[lookup_order, lookup_customer]
)

returns_agent = Agent[EcommerceContext](
    name="Returns & Exchanges Specialist",
    instructions="""
    You are a returns and exchanges specialist for ShopSmart.
    
    Return Policy:
    - 30-day return window for most items
    - Items must be unused and in original packaging
    - Free returns for defective items
    - Customer pays return shipping for non-defective items
    
    Process:
    1. Verify order and customer information
    2. Check return eligibility
    3. Explain return process clearly
    4. Generate return authorization if approved
    5. Provide return shipping instructions
    
    Always be understanding about customer concerns and look for win-win solutions.
    """,
    tools=[lookup_order, lookup_customer]
)

account_agent = Agent[EcommerceContext](
    name="Account Management Specialist", 
    instructions="""
    You are an account management specialist for ShopSmart.
    
    Responsibilities:
    - Account settings and preferences
    - Subscription management
    - Loyalty program questions
    - Account security issues
    - Profile updates
    
    Customer Tiers & Benefits:
    - Bronze: Standard support, regular shipping
    - Silver: Priority support, free shipping over $50
    - Gold: Priority support, free shipping, 5% discount
    - Platinum: VIP support, free express shipping, 10% discount
    
    Always highlight tier benefits and upgrade opportunities when appropriate.
    """,
    tools=[lookup_customer]
)

# Handoff data models
class OrderHandoffData(BaseModel):
    order_id: str
    issue_type: str
    customer_tier: str

class ReturnHandoffData(BaseModel):
    order_id: str
    return_reason: str
    customer_tier: str

class AccountHandoffData(BaseModel):
    customer_email: str
    issue_category: str
    customer_tier: str

# Handoff callbacks
async def on_order_handoff(ctx: RunContextWrapper[EcommerceContext], data: OrderHandoffData):
    ctx.context.add_note(f"Handoff to Order Tracking: {data.issue_type} for order {data.order_id}")
    print(f"üìä Order tracking handoff: {data.issue_type} ({data.customer_tier} customer)")

async def on_return_handoff(ctx: RunContextWrapper[EcommerceContext], data: ReturnHandoffData):
    ctx.context.add_note(f"Handoff to Returns: {data.return_reason} for order {data.order_id}")
    print(f"üìä Returns handoff: {data.return_reason} ({data.customer_tier} customer)")

async def on_account_handoff(ctx: RunContextWrapper[EcommerceContext], data: AccountHandoffData):
    ctx.context.add_note(f"Handoff to Account Management: {data.issue_category}")
    print(f"üìä Account management handoff: {data.issue_category} ({data.customer_tier} customer)")

# Main customer service agent
customer_service_agent = Agent[EcommerceContext](
    name="ShopSmart Customer Service",
    instructions="""
    You are the main customer service agent for ShopSmart e-commerce.
    
    Your role:
    - First point of contact for all customer inquiries
    - Intelligent routing to appropriate specialists
    - Handle simple questions independently
    - Gather necessary information before handoffs
    
    Routing Logic:
    - Order status, shipping, tracking ‚Üí Order Tracking Specialist
    - Returns, exchanges, refunds ‚Üí Returns & Exchanges Specialist  
    - Account issues, subscriptions, profile ‚Üí Account Management Specialist
    
    Before handoffs:
    - Gather customer email and/or order ID
    - Understand the specific issue
    - Set customer expectations about the handoff
    
    Customer Tier Priority:
    - Platinum/Gold: Immediate attention, proactive solutions
    - Silver: Standard priority, helpful service
    - Bronze: Standard service, suggest upgrades when appropriate
    """,
    handoffs=[
        handoff(
            agent=order_tracking_agent,
            on_handoff=on_order_handoff,
            input_type=OrderHandoffData,
            tool_name_override="transfer_to_order_tracking"
        ),
        handoff(
            agent=returns_agent,
            on_handoff=on_return_handoff, 
            input_type=ReturnHandoffData,
            tool_name_override="transfer_to_returns"
        ),
        handoff(
            agent=account_agent,
            on_handoff=on_account_handoff,
            input_type=AccountHandoffData,
            tool_name_override="transfer_to_account_management"
        )
    ],
    tools=[lookup_order, lookup_customer]
)

# Demo the complete e-commerce support system
async def demo_ecommerce_support():
    from agents import Runner
    
    print("üõçÔ∏è **ShopSmart Customer Service Simulation**\n")
    
    context = EcommerceContext()
    
    scenarios = [
        {
            "query": "Hi, I want to check the status of my order ORD-12345",
            "description": "Order tracking inquiry"
        },
        {
            "query": "I received my wireless headphones but they're defective. I want to return them. My email is alice@example.com",
            "description": "Return request"
        },
        {
            "query": "I can't log into my account and I want to update my shipping address",
            "description": "Account management issue"
        },
        {
            "query": "What are the benefits of upgrading to Gold tier?",
            "description": "General inquiry (no handoff needed)"
        }
    ]
    
    for i, scenario in enumerate(scenarios, 1):
        print(f"**Scenario {i}: {scenario['description']}**")
        print(f"Customer: {scenario['query']}")
        
        result = await Runner.run(customer_service_agent, scenario['query'], context=context)
        
        print(f"Final Handler: {result.last_agent.name}")
        print(f"Response: {result.final_output}")
        
        # Show session notes
        if context.session_notes:
            print(f"Session Notes: {'; '.join(context.session_notes[-2:])}")
        
        print("-" * 80 + "\n")
        
        # Reset context for next scenario
        context = EcommerceContext()

if __name__ == "__main__":
    import asyncio
    asyncio.run(demo_ecommerce_support())
```

## Best Practices v√† Patterns

### 1. Handoff Decision Matrix

```python
# Pattern: Decision matrix trong instructions
TRIAGE_DECISION_MATRIX = """
# Handoff Decision Matrix

## Order-Related Issues
- Order status, tracking ‚Üí Order Tracking Agent
- Shipping delays, delivery issues ‚Üí Order Tracking Agent
- Order modifications, cancellations ‚Üí Order Management Agent

## Product & Returns
- Product defects, quality issues ‚Üí Returns Agent
- Return requests, exchanges ‚Üí Returns Agent
- Warranty claims ‚Üí Returns Agent

## Billing & Payments
- Payment failures, billing disputes ‚Üí Billing Agent
- Refund requests ‚Üí Billing Agent (if simple) or Returns Agent (if product-related)
- Subscription management ‚Üí Account Agent

## Technical Issues
- Website bugs, app crashes ‚Üí Technical Support Agent
- API integration problems ‚Üí Technical Support Agent
- Performance issues ‚Üí Technical Support Agent

## Escalation Triggers
- Customer mentions "manager", "supervisor" ‚Üí Escalation Agent
- Unresolved after 3+ interactions ‚Üí Escalation Agent
- Threats, legal language ‚Üí Escalation Agent
"""

specialized_triage_agent = Agent(
    name="Expert Triage Agent",
    instructions=f"""
    You are an expert customer service triage agent.
    
    {TRIAGE_DECISION_MATRIX}
    
    Your process:
    1. Listen carefully to understand the core issue
    2. Ask clarifying questions if needed
    3. Consult the decision matrix above
    4. Route to the most appropriate specialist
    5. Provide context to the specialist
    """,
    handoffs=[...] # All specialized agents
)
```

### 2. Recommended Prompts Pattern

```python
from agents.extensions.handoff_prompt import prompt_with_handoff_instructions

# S·ª≠ d·ª•ng recommended prompts cho better handoff understanding
enhanced_agent = Agent(
    name="Enhanced Agent",
    instructions=prompt_with_handoff_instructions("""
    Your core instructions here...
    """),
    handoffs=[other_agent]
)

# Ho·∫∑c manual inclusion
HANDOFF_INSTRUCTIONS = """
# Handoff Guidelines

When you need to transfer a conversation:
1. Explain to the user why you're transferring them
2. Summarize what you've learned so far
3. Set expectations about what the specialist will help with
4. Use the appropriate transfer tool

Available transfers:
- transfer_to_billing_agent: For billing, payments, and financial issues
- transfer_to_technical_agent: For technical problems and integrations
- escalate_to_manager: For complex issues requiring senior attention

Example: "I can see you're having a billing issue. Let me transfer you to our billing specialist who can access your account details and resolve this quickly."
"""
```

### 3. Context Preservation Pattern

```python
def create_context_preserving_filter(important_keys: List[str]):
    """Create filter that preserves important context"""
    def context_filter(input_data: HandoffInputData) -> HandoffInputData:
        # Preserve conversation context
        filtered_input = input_data.copy()
        
        # Add context summary
        context_summary = []
        for key in important_keys:
            if hasattr(input_data, key):
                context_summary.append(f"{key}: {getattr(input_data, key)}")
        
        if context_summary:
            context_message = {
                "role": "system",
                "content": f"Context from previous conversation: {'; '.join(context_summary)}"
            }
            filtered_input.input.insert(0, context_message)
        
        return filtered_input
    
    return context_filter

# Usage
context_preserving_handoff = handoff(
    agent=specialist_agent,
    input_filter=create_context_preserving_filter(['customer_tier', 'order_id', 'issue_type'])
)
```

### 4. Monitoring v√† Analytics

```python
import time
from typing import Dict
from collections import defaultdict

class HandoffAnalytics:
    def __init__(self):
        self.handoff_counts: Dict[str, int] = defaultdict(int)
        self.handoff_times: Dict[str, List[float]] = defaultdict(list)
        self.success_rates: Dict[str, List[bool]] = defaultdict(list)
    
    async def track_handoff(self, from_agent: str, to_agent: str, success: bool, duration: float):
        handoff_key = f"{from_agent} ‚Üí {to_agent}"
        self.handoff_counts[handoff_key] += 1
        self.handoff_times[handoff_key].append(duration)
        self.success_rates[handoff_key].append(success)
    
    def get_analytics_report(self) -> str:
        report = "üìä **Handoff Analytics Report**\n\n"
        
        for handoff_key, count in self.handoff_counts.items():
            avg_time = sum(self.handoff_times[handoff_key]) / len(self.handoff_times[handoff_key])
            success_rate = sum(self.success_rates[handoff_key]) / len(self.success_rates[handoff_key]) * 100
            
            report += f"**{handoff_key}:**\n"
            report += f"‚Ä¢ Count: {count}\n"
            report += f"‚Ä¢ Avg Duration: {avg_time:.2f}s\n" 
            report += f"‚Ä¢ Success Rate: {success_rate:.1f}%\n\n"
        
        return report

# Global analytics tracker
analytics = HandoffAnalytics()

async def tracked_handoff_callback(ctx: RunContextWrapper, data: BaseModel):
    start_time = time.time()
    
    # Your handoff logic here
    
    duration = time.time() - start_time
    await analytics.track_handoff(
        from_agent="Triage Agent",
        to_agent="Specialist Agent", 
        success=True,  # Determine based on your criteria
        duration=duration
    )
```

## Production Considerations

### 1. Error Handling v√† Fallbacks

```python
from agents.exceptions import AgentsException

class RobustAgent(Agent):
    def __init__(self, fallback_agent: Agent, **kwargs):
        super().__init__(**kwargs)
        self.fallback_agent = fallback_agent
    
    async def run_with_fallback(self, input_data, context=None):
        try:
            result = await Runner.run(self, input_data, context=context)
            return result
        except AgentsException as e:
            print(f"Primary agent failed: {e}. Falling back...")
            return await Runner.run(self.fallback_agent, input_data, context=context)

# Usage
primary_agent = Agent(name="Primary", instructions="...")
fallback_agent = Agent(name="Fallback", instructions="Handle any general inquiries...")

robust_agent = RobustAgent(
    fallback_agent=fallback_agent,
    name="Robust Primary Agent",
    instructions="...",
    handoffs=[...]
)
```

### 2. Rate Limiting v√† Resource Management

```python
import asyncio
from typing import Dict
from datetime import datetime, timedelta

class HandoffRateLimiter:
    def __init__(self, max_handoffs_per_minute: int = 10):
        self.max_handoffs = max_handoffs_per_minute
        self.handoff_timestamps: Dict[str, List[datetime]] = defaultdict(list)
    
    async def check_rate_limit(self, agent_name: str) -> bool:
        now = datetime.now()
        recent_handoffs = [
            ts for ts in self.handoff_timestamps[agent_name]
            if now - ts < timedelta(minutes=1)
        ]
        
        self.handoff_timestamps[agent_name] = recent_handoffs
        
        if len(recent_handoffs) >= self.max_handoffs:
            return False
        
        self.handoff_timestamps[agent_name].append(now)
        return True

# Global rate limiter
rate_limiter = HandoffRateLimiter(max_handoffs_per_minute=5)

async def rate_limited_handoff_callback(ctx: RunContextWrapper, data: BaseModel):
    if not await rate_limiter.check_rate_limit("specialist_agent"):
        raise Exception("Rate limit exceeded. Please try again later.")
    
    # Continue with handoff
    print(f"Handoff approved: {data}")
```

## T·ªïng K·∫øt v√† Nh·ªØng ƒêi·ªÅu C·∫ßn Nh·ªõ

### Nh·ªØng G√¨ Ch√∫ng Ta ƒê√£ H·ªçc

‚úÖ **Handoffs Fundamentals** - C√°ch agents ·ªßy quy·ªÅn cho nhau hi·ªáu qu·∫£  
‚úÖ **Customization Patterns** - Input data, callbacks, v√† filters  
‚úÖ **Real-world Architecture** - Multi-agent e-commerce support system  
‚úÖ **Best Practices** - Decision matrices, context preservation, monitoring  
‚úÖ **Production Patterns** - Error handling, rate limiting, analytics  

### Core Principles cho Multi-Agent Systems

üéØ **Single Responsibility** - M·ªói agent ƒë·∫£m nh·∫≠n ƒë√∫ng m·ªôt lƒ©nh v·ª±c chuy√™n m√¥n.  
üîÑ **Seamless Handoffs** - Context ƒë∆∞·ª£c truy·ªÅn ti·∫øp ƒë·∫ßy ƒë·ªß, kh√¥ng ƒë·ªÉ l·ªô hay m·∫•t m√°t th√¥ng tin.  
üìä **Intelligent Routing** - Quy·∫øt ƒë·ªãnh chuy·ªÉn giao d·ª±a tr√™n ma tr·∫≠n nghi·ªáp v·ª• v√† d·ªØ li·ªáu kh√°ch h√†ng.  
üõ°Ô∏è **Robust Error Handling** - Graceful degradation v√† fallback mechanisms  
üìà **Observability** - Theo d√µi s·ªë l∆∞·ª£ng, th·ªùi gian v√† t·ªâ l·ªá th√†nh c√¥ng c·ªßa m·ªói handoff.

### H∆∞·ªõng d·∫´n tri·ªÉn khai

1. **Giai ƒëo·∫°n thi·∫øt k·∫ø**

   * X√°c ƒë·ªãnh r√µ tr√°ch nhi·ªám c·ªßa t·ª´ng agent.
   * L·∫≠p ma tr·∫≠n quy·∫øt ƒë·ªãnh (decision matrix) cho c√°c lo·∫°i y√™u c·∫ßu.
   * ƒê·ªãnh nghƒ©a c√°ch b·∫£o v·ªá v√† l·ªçc context (input filters, security).
   * V·∫°ch s·∫µn lu·ªìng fallback khi handoff kh√¥ng th√†nh c√¥ng.

2. **Giai ƒëo·∫°n ph√°t tri·ªÉn**

   * T·∫°o c√°c agent chuy√™n bi·ªát v·ªõi instructions r√µ r√†ng.
   * X√¢y d·ª±ng c√°c tool handoff v·ªõi callback v√† input\_type tu·ª≥ ch·ªânh.
   * √Åp d·ª•ng filter ƒë·ªÉ lo·∫°i b·ªè th√¥ng tin nh·∫°y c·∫£m v√† t√≥m t·∫Øt context d√†i.
   * T√≠ch h·ª£p monitoring/analytics ƒë·ªÉ thu th·∫≠p d·ªØ li·ªáu handoff.
   * Th√™m c∆° ch·∫ø rate limiting, error handling v√† fallback agents.

3. **Giai ƒëo·∫°n ki·ªÉm th·ª≠**

   * Test m·ªçi ng·∫£ handoff (ƒë∆∞·ªùng ƒëi ch√≠nh, c√°c tr∆∞·ªùng h·ª£p edge-case).
   * Ki·ªÉm tra t√≠nh to√†n v·∫πn c·ªßa context sau m·ªói handoff.
   * ƒê√°nh gi√° hi·ªáu nƒÉng v√† t·∫ßn su·∫•t handoff; ƒë·∫£m b·∫£o kh√¥ng qu√° t·∫£i.
   * X√°c th·ª±c c∆° ch·∫ø fallback v√† x·ª≠ l√Ω l·ªói.

4. **Giai ƒëo·∫°n v·∫≠n h√†nh**

   * Thi·∫øt l·∫≠p dashboard gi√°m s√°t handoff counts, avg time, success rate.
   * C·∫•u h√¨nh rate limiting ph√π h·ª£p v·ªõi l∆∞u l∆∞·ª£ng th·ª±c t·∫ø.
   * Theo d√µi logs ƒë·ªÉ ph√°t hi·ªán circular handoffs ho·∫∑c context loss.
   * C·∫≠p nh·∫≠t ma tr·∫≠n routing v√† n√¢ng c·∫•p agents theo nhu c·∫ßu.

---

### Nh·ªØng anti-pattern c·∫ßn tr√°nh

* **Chuy·ªÉn giao qu√° nhi·ªÅu l·∫ßn** khi·∫øn kh√°ch h√†ng m·∫•t ki√™n nh·∫´n.
* **M·∫•t context** l√†m specialist kh√¥ng bi·∫øt chuy·ªán g√¨ ƒë√£ x·∫£y ra.
* **Circular handoffs** (agent n√†y g·ª≠i l·∫°i agent kia).
* **Agents qu√° generic** thi·∫øu chuy√™n m√¥n s√¢u.
* **Kh√¥ng c√≥ fallback** khi handoff th·∫•t b·∫°i.

---

### B∆∞·ªõc Ti·∫øp Theo

Trong **b√†i ti·∫øp theo**, ch√∫ng ta s·∫Ω kh√°m ph√°:

üõ°Ô∏è **Guardrails** - B·∫£o v·ªá v√† ki·ªÉm so√°t agent behavior  
üîí **Security Patterns** - Input validation, content filtering  
‚ö° **Performance Optimization** - Caching, rate limiting, monitoring  

### Th·ª≠ Th√°ch Cho B·∫°n

1. Thi·∫øt k·∫ø h·ªá th·ªëng multi-agent cho m·ªôt domain b·∫°n ƒëang quan t√¢m.
2. Vi·∫øt filter t√πy ch·ªânh ƒë·ªÉ b·∫£o v·ªá privacy/security khi handoff.
3. X√¢y d·ª±ng dashboard analytics cho handoff ‚Äî s·ªë l∆∞·ª£ng, th·ªùi gian, t·ªâ l·ªá th√†nh c√¥ng.
4. Th·ª≠ nghi·ªám c√°c chi·∫øn l∆∞·ª£c ph√¢n chia responsibilities kh√°c nhau v√† so s√°nh k·∫øt qu·∫£.

---

*B√†i ti·∫øp theo: [**"Guardrails: B·∫£o V·ªá v√† Ki·ªÉm So√°t Agent Behavior Hi·ªáu Qu·∫£"**](../openai-agents-sdk-part-05-guardrails-security-validation/) - Ch√∫ng ta s·∫Ω h·ªçc c√°ch x√¢y d·ª±ng c√°c l·ªõp b·∫£o v·ªá ƒë·ªÉ ƒë·∫£m b·∫£o agents ho·∫°t ƒë·ªông an to√†n v√† ƒë√∫ng m·ª•c ƒë√≠ch.*